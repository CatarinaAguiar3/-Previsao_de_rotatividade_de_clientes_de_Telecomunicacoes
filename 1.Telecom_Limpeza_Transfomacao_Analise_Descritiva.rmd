---
title: "Previsão de rotatividade de clientes de Telecomunicações"
date: ''
output:
  rmdformats::readthedown:
    highlight: kate
    toc_depth: 5
    keep_md: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# 1. Introdução

## 1.1 Contextulização

A rotatividade de clientes (churn) é definida como a propensão dos clientes a deixarem de fazer negócios com uma empresa em um determinado período de tempo (XIE et al., 2009). Isso pode acontecer por diversos motivos, como a insatisfação do cliente com a serviço da empresa. A ciência de dados pode ajudar as empresas na previsão do churn.

Extraído do site [Kaggle](https://www.kaggle.com/datasets/abhinav89/telecom-customer) , este conjunto de dados apresenta 100 variáveis e aproximadamente 100 mil registros. Ele contém diversas variáveis que detalham os atributos da indústria de telecomunicações, além de fatores cruciais ao lidar com os clientes desse setor. A variável central é a rotatividade, indicando se o cliente está propenso a abandonar o serviço.

## 1.2 Objetivo

Este conjunto de dados será usado para prever se os clientes abandonarão ou não esta de empresa de Telecomunicações.

## 1.3 Metodologia (...)

![](images/fluxograma1-01.png)

Os passos utilizados neste projeto são os seguintes:

1.Introdução

2.Coleta dos dados

3.Descrição dos dados

4.Transformação dos dados

5.Limpeza dos dados

6.Análise descritiva

7.Modelagem

7.1 Dividir o dataset em treino.teste e validação

7.2 Padronizar

7.3 Treinar os modelos

-   Serão escolhidos os modelos : regressão logística , Random forest, XGboost e lightGM. Em seguida, será avaliado qual o melhor modelo para a análise.

7.4 Cross-Validation, teste

7.5 Avaliação das métricas

-   Verificar a acuraria, precisão, ACU, curva ROC

7.6 Otimização de hiper-parâmetros

7.7 Obter o modelo final e marcar os dados

8.Gerar o reporte

## 1.4 Seleção dos Preditores

Escolher as variáveis explicativas certas é fundamental para a construção de um bom modelo.A análise descritiva ajudará nesse quesito. Além disso, foi realizado uma pesquisa na literatura para verificar quais variáveis estão associadas ao churn. A tabela a seguir é uma adapatação do trabalho de (KERAMATI et al., 2014).

|     | Literatura                                | Churn Determinístico na literatura                                             | Código no dataset | Descrição do código no dataset                                                                                                                                                                                                                                        |
|-----|-------------------------------------------|--------------------------------------------------------------------------------|-------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 1   | (GOPAL; MEHER, 2008) e (LEE et al., 2011) | Número de meses em serviço                                                     | **months**        | Número total de meses de serviço                                                                                                                                                                                                                                      |
| 2   | (GOPAL; MEHER, 2008)                      | Qualidade de serviço ruim                                                      | **truck**         | Indicador de caminhão. Um um indicador de caminhão é um dispositivo usado para medir a qualidade do sinal de uma rede de telefonia celular. O indicador é instalado em um caminhão e mede o sinal em várias áreas, incluindo áreas rurais, urbanas e suburbanas.      |
| 3   | (GOPAL; MEHER, 2008)                      | Qualidade de serviço ruim                                                      | **rv**            | Indicador de RV. É um indicador usado para medir a qualidade do sinal de uma rede de telefonia celular em áreas rurais. O indicador é instalado em uma caravana ou trailer e mede o sinal em várias áreas, incluindo estradas rurais, fazendas e comunidades remotas. |
| 4   | (GOPAL; MEHER, 2008) e (KIM; YOON, 2004)  | Falhas                                                                         | **drop_vce_Mean** | Número médio de chamadas de voz perdidas (com falha)                                                                                                                                                                                                                  |
| 5   | (GOPAL; MEHER, 2008) e (KIM; YOON, 2004)  | Falhas                                                                         | **drop_dat_Mean** | Número médio de chamadas de dados perdidas (com falha). Ou seja, é uma falha na qual uma conexão de dados é interrompida antes que a transferência de dados seja concluída. Ex: Falha ao baixar um arquivo da internet.                                               |
| 6   | (GOPAL; MEHER, 2008) e (KIM; YOON, 2004)  | Falhas                                                                         | **blck_vce_Mean** | Número médio de chamadas de voz bloqueadas (com falha)                                                                                                                                                                                                                |
| 7   | (GOPAL; MEHER, 2008) e (KIM; YOON, 2004)  | Falhas                                                                         | **blck_dat_Mean** | Número médio de chamadas de dados bloqueadas (com falha)                                                                                                                                                                                                              |
| 8   | (ZHANG et al., 2012)                      | Preços                                                                         | **hnd_price**     | Preço atual do aparelho                                                                                                                                                                                                                                               |
| 9   | (ZHANG et al., 2012) e (LEE et al., 2011) | Contagem de chamadas mensais                                                   | **avgqty**        | Número médio mensal de chamadas ao longo da vida do cliente                                                                                                                                                                                                           |
| 10  | (ZHANG et al., 2012)                      | conjunto de cobrança                                                           | **rev_Mean**      | Receita média mensal (valor da cobrança)                                                                                                                                                                                                                              |
| 11  | (ZHANG et al., 2012)                      | conjunto de cobrança                                                           | **totmrc_Mean**   | Média de cobrança recorrente mensal total                                                                                                                                                                                                                             |
| 12  | (LEE et al., 2011)                        | Número de dias de equipamento                                                  | **eqpdays**       | Número de dias (idade) do equipamento atual                                                                                                                                                                                                                           |
| 13  | (LEE et al., 2011)                        | Intervalo de minutos excedentes de uso                                         | **ovrmou_Mean**   | Média de minutos excedentes de uso                                                                                                                                                                                                                                    |
| 16  | (LEE et al., 2011)                        | Média de minutos não arredondados de uso de chamadas de voz concluídas         | **mou_cvce_Mean** | Média de minutos não arredondados de uso de chamadas de voz concluídas                                                                                                                                                                                                |
| 15  | (LEE et al., 2011)                        | Limite de gastos da conta                                                      | **asl_flag**      | Limite de gastos da conta                                                                                                                                                                                                                                             |
| 17  | (LEE et al., 2011)                        | Total de minutos ajustados ao faturamento ao longo da vida do cliente          | **totmou**        | Total de minutos de uso ao longo da vida do cliente                                                                                                                                                                                                                   |
| 18  | (LEE et al., 2011)                        | Média do número de minutos de uso                                              | **avgmou**        | Média mensal de minutos de uso ao longo da vida do cliente                                                                                                                                                                                                            |
| 19  | (LEE et al., 2011)                        | Faixa de receita de excedente de **voz**                                       | **vceovr_Mean**   | Receita média de excedente de voz                                                                                                                                                                                                                                     |
| 20  | (LEE et al., 2011)                        | Faixa de receita de excedente                                                  | **ovrrev_Mean**   |                                                                                                                                                                                                                                                                       |
| 21  | (LEE et al., 2011)                        | Variação percentual em minutos mensais de uso vs. média dos 3 meses anteriores | **change_mou**    | Alteração percentual nos minutos mensais de uso em relação à média dos três meses anteriores                                                                                                                                                                          |
| 22  | (LEE et al., 2011)e (KIM; JUN; LEE, 2014) | Telefone atual (recondicionado ou novo)                                        | **refurb_new**    | Aparelho: recondicionado ou novo                                                                                                                                                                                                                                      |
| 23  | (TSAI; CHEN, 2010) e (KIM; YOON, 2004)    | A velocidade de upload e download de dados                                     | **hnd_webcap**    | Capacidade web do aparelho                                                                                                                                                                                                                                            |
| 24  | (HUNG; YEN; WANG, 2006)                   |  Customer Demographic                                                          | **area**          | Área geográfica                                                                                                                                                                                                                                                       |
| 25  | (HUNG; YEN; WANG, 2006)                   | Faixas de classe social                                                        | **income**        | Renda estimada                                                                                                                                                                                                                                                        |
| 26  | (Huang ; Kechadi, 2013)                   | Tipos de chamadas (por exemplo, chamadas internacionais ou locais)             | **roam_Mean**     | Número médio de chamadas em roaming (quando o cliente de uma operadora sai da área de cobertura da qual foi cadastrado)                                                                                                                                               |
| 27  | (Huang ; Kechadi, 2013)                   | Tipos de chamadas (por exemplo, chamadas internacionais ou locais)             | **roam_Mean**     | Número médio de chamadas em roaming (quando o cliente de uma operadora sai da área de cobertura da qual foi cadastrado)                                                                                                                                               |
| 28  | (LU et al., 2014)                         |  Informações de entrada/saída de atendimento ao cliente                        | **cc_mou_Mean**   | Média de minutos não arredondados de uso de chamadas de atendimento ao cliente .                                                                                                                                                                                      |

### 

### 1.4.1 Critério para seleção das preditoras

O critério de seleção para as variáveis preditoras será primeiro a análise do gráfico e da literatura. Caso a diferença no gráfico seja sutil, será realizado um teste de hipótese, somente nas variáveis numéricas.

-   Se a diferença no gráfico for grande, então a variável será incluída como preditora.

-   Se a diferença no gráfico for sutil mas a variável estiver na literatura, a tendência é inclui-la na lista de preditoras.

-   Se a diferença for sutil e a variável numérica, não estiver na literatura, será feito um teste de hipótese. E, em caso de rejeitar a Ho, a variável será incluída como preditora.

-   Se a diferença for sutil e a variável não for numérica, será avaliada individualmente.

Com base no conjunto de todas as informações descritas, as variáveis serão escolhidas

![](images/Diag1.2-03.png)

------------------------------------------------------------------------

![](images/Dig2.2-03.png)

#### 

------------------------------------------------------------------------

![](images/Diag3-01.png)

## 1.5 Modelo Logístico

A regressão logística é um modelo linear para classificação no qual a variável dependente é binária e categórica.

Ele é resultado de uma transformação da regressão linear. Após a transformação logarítmica temos um modelo que encontra a probabilidade de algo acontecer.

Com a regressão logística é possível, por exemplo, encontrar a probabilidade de um cliente deixar uma empresa (churn). Essa informação pode ajudar os gestores a direcionar seus esforços para clientes com maiores chances de churn.

## 1.6 Random forest

## 1.7 XGBoost

## 1.8 LightGBM

# 2. Coleta dos dados

#### 2.1 Carregar os pacotes

```{r, message=FALSE, warning=FALSE}
library(dplyr)
library(data.table)
library(tidyr)
library(ggplot2)
library(tidyverse)
library(psych) # função describe
library(ggcorrplot) # grafico de correlação
library(pastecs)
library(dummy) #Criar dummy: linhas passam a ser colunas binárias 
library(caret) #padronizar dados
library(randomForest) #Usar no algoritmo Random Forest
library(boot)#Fazer CrossValidation
library(glmnet)#Fazer regularização de LASSO
library(caret) #Fazer avaliação dos modelos
library(fastDummies) 
library(stats) #Métrica KS
#install.packages("ROCR")
library(ROCR)#para fazer a curva ROC
library(pROC)
```

```{r}
#Boruta
#("ParamHelpers")
library(ParamHelpers)

#install.packages("mlr")
library(mlr)

#install.packages("Boruta")
library(Boruta)

```

#### 2.2 Carregar a base de dados

```{r, message=FALSE, warning=FALSE}
dados <- read.csv("C:/0.Projetos/2.Telecom_customer_(Churn)/Dataset/Telecom_customer_churn.csv")

```

```{r}
#head(dados)
```

# 3. Descrever os dados

#### Descrição das colunas

![](images/Dicionario.png)

#### Número de linhas e colunas

```{r}
#Numero de linhas e colunas
n_linhas <- nrow(dados)

n_colunas <- ncol(dados)

cat("O conjunto de dados tem", n_linhas,"linhas e", n_colunas,"colunas.")

```

#### Tipo de dados

```{r}
#Verificando o formato das colunas
data.frame(sapply(dados, class))
```

```{r}
# Encontrar colunas com caracteres (Strings)
colunas_caracteres <- names(dados)[sapply(dados, is.character)]
colunas_caracteres

```

```{r}
#Quantidade de colunas com caracteres (Strings)
length(colunas_caracteres)
```

```{r}
# Encontrar colunas com dados numericos 
colunas_numeric <- names(dados)[sapply(dados, is.numeric)]
colunas_numeric
```

```{r}
#Quantidade de colunas com dados numericos
length(colunas_numeric)
```

#### Conclusão

Existem 100 colunas divididas em dois tipos de dados: 21 variaveis do tipo *character* e 79 variáveis do tipo *numeric.*

-   Variáveis do tipo character: `churn`, `new_cell`, `crclscod`, `asl_flag`, `prizm_social_one`, `area`, `dualband`, `refurb_new`, `hnd_webcap`, `ownrent`, `dwlltype`, `marital`, `infobase`, `HHstatin`, `dwllsize`, `ethnic` , `kid0_2`, `kid3_5`, `kid6_10` , `kid11_15`, `kid16_17`, `creditcd`

-   Variáveis numéricas:  `months` , `uniqsubs`, `actvsubs`, `totcalls`, `adjqty`, `avg3mou` , \`avg3qty\`, \`avg3rev\`, \`rev_Mean\`, \`mou_Mean\`, \`totmrc_Mean\`, \`da_Mean\`, \`ovrmou_Mean\`, \`ovrrev_Mean\`, \`vceovr_Mean\`, \`datovr_Mean\`, \`roam_Mean\`, \`change_mou\`, \`change_rev\`, \`drop_vce_Mean\`, \`drop_dat_Mean\`, \`blck_vce_Mean\`, \`blck_dat_Mean\`, \`unan_vce_Mean\`, \`unan_dat_Mean\`, \`plcd_vce_Mean\`, \`plcd_dat_Mean\`, \`recv_vce_Mean\`, \`recv_sms_Mean\`, \`comp_vce_Mean\`, \`comp_dat_Mean\`, \`custcare_Mean\`, \`ccrndmou_Mean\`, \`cc_mou_Mean\`, \`inonemin_Mean\`, \`threeway_Mean\`, \`mou_cvce_Mean\`, \`mou_cdat_Mean\`, \`mou_rvce_Mean\`, \`owylis_vce_Mean\`, \`mouowylisv_Mean\`, \`iwylis_vce_Mean\`, \`mouiwylisv_Mean\`, \`peak_vce_Mean\`, \`peak_dat_Mean\`, \`mou_peav_Mean\`, \`mou_pead_Mean\`, \`opk_vce_Mean\`, \`opk_dat_Mean\`, \`mou_opkv_Mean\`, \`mou_opkd_Mean\`, \`drop_blk_Mean\`, \`attempt_Mean\`, \`complete_Mean\`, \`callfwdv_Mean\`, \`callwait_Mean\`, \`totmou\`, \`totrev\`, \`adjrev\`, \`adjmou\`, \`avgrev\`, \`avgmou\`, \`avgqty\`, \`avg6mou\`, \`avg6qty\`, \`avg6rev\`, \`hnd_price\`, \`phones\`, \`models\`, \`truck\`, \`rv\`, \`lor\`, \`adults\`, \`income\`, \`numbcars\`, \`forgntvl\`, \`eqpdays\`

#### Porcentagem de dados nulos

```{r}
#Porcentagem Dados Nulos
porcentagem_nulos <- colSums(is.na(dados))/nrow(dados)*100
data.frame(porcentagem_nulos)

```

```{r}
#Colocando a porcentagem de dados nulos em ordem descrescente
nulos <- sort(porcentagem_nulos, decreasing = TRUE)
nulos2 <- data.frame(nulos)

#print(nulos2)

```

Algumas colunas tem números significativos de dados nulos , como numbcars (49.4%) , lor (30.2%) , income (25.4%) , adults (23%) e hnd_webcap (10.2%) .

Para descobrir o que fazer, deve-se analisar cada uma.

##### Coluna numbcars

```{r}
#Checar dados nulos
unique(dados$numbcars)

```

A coluna numbcars representa a quantidade de carros do cliente. Na base de dados, não tem nenhum valor representando zero carros. Logo, é poss´´ivel concluir que NA significa clientes com zero carros. Então, o ideal será trocar NA por 0.

##### Coluna lor

Representa o tempo de residência do cliente. Esta informação não é relevante para Churn. Logo, pode-se eliminá-la.

##### Coluna income

Representa a renda estimada. Esta é uma informação relevante, logo não é ideal retirar a coluna. Uma solução é eliminar as linhas com NA.

##### Coluna adults

Representa o número de adultos na residência. Esta também não é informação não é relevante para Churn. Logo, pode-se eliminá-la.

##### Coluna hnd_webcap

Representa a capacidade web do aparelho. Segundo (TSAI; CHEN, 2010) e (KIM; YOON, 2004) esta informação pode ser relevante para Churn. Uma solução é eliminar as linhas com NA.

##### Em resumo:

-   numbcars: trocar NA por zero

-   lor: retirar a coluna, pois não é relevante para Churn

-   income: eliminar as linhas com NA

-   adults: retirar esta coluna

-   hnd_webcap: eliminar as linhas com NA

# 4. Limpeza dos dados

#### 1ª Passo: Trocar NA por zero na coluna numbcars

```{r}
#Criar uma nova base 
dados2 <- dados
```

```{r}
# 1º Trocar NA por zero na coluna numbcars
dados2$numbcars[is.na(dados2$numbcars)] <- 0

```

#### 2º Passo: Tirar as colunas lor e adults

```{r}
# 2º Tirar as colunas
dados2 <- subset(dados2, select = -c(lor, adults))

```

```{r}
#Verificar o resultado
dim(dados2)
```

#### 3º Passo: Eliminar as NA´s

```{r}
# 3º Eliminar as NAs
dados2 <- na.omit(dados2)

anyNA(dados2)
```

#### 4º Checar novamente a quantidade de dados nulos

```{r}
#Transformar dados3 num data.frame
dados2 <- data.frame(dados2)
```

```{r}
#Porcentagem Dados Nulos
porcentagem_nulos2 <- colSums(is.na(dados2))/nrow(dados2)*100
#data.frame(porcentagem_nulos2)
```

```{r, message=FALSE, warning=FALSE}
#Colocando a porcentagem de dados nulos em ordem descrescente
nulos3 <- sort(porcentagem_nulos2, decreasing = TRUE)
nulos4 <- data.frame(nulos3)

anyNA(nulos4)


```

```{r}
#Visão Geral da base dados3
#head(dados2)
```

#### Salvar os dados limpos em csv

```{r, warning=FALSE}
#Alterar o caminho do diretório para a pasta com os datasets
#setwd("C:/0.Projetos/2.Telecom_customer_(Churn)/Dataset")
#dir()

```

```{r}
#Salvar a base de dados
#write.csv(dados2,"dados_limpos.csv", row.names=FALSE)
```

```{r}
#Retornar para o diretório com os scripts
#setwd("C:/0.Projetos/2.Telecom_customer_(Churn)/Scripts")
#dir()
```

# 5. Transformação dos dados

O que será feito nesta etapa:

-   Retirada de algumas colunas

-   Agrupamento da coluna kids

## 5.1 Retirada de variáveis

Algumas colunas serão irrelevantes para a análise.

-   A coluna `prizm_social_one` , `iwylis_vce_Mean` e `infobase` não estão bem específicadas na documentação.

-   A coluna `ccrndmou_Mean` apresenta os números arredondados, porém há outra variável que apresenta os mesmos números sem arredondar.

```{r}
#Retirando 4 colunas
dados3 <- dados2 %>% select(-prizm_social_one, -iwylis_vce_Mean,-infobase , -ccrndmou_Mean)

```

```{r}
#Verificando o número de colunas de uma tabela
ncol(dados2)
ncol(dados3)
```

## 5.2 Transformação de variáveis

O dataset apresenta 4 categorias para o caso do cliente ter filhos. Transformaremos essas 4 colunas em uma só, criando uma variável binária em que 0 significa não ter filho e 1 significa ter filhos.

```{r}
#kid=1 significa ter filhos
#kid=0 significa não ter filhos
# Converta as colunas relacionadas à presença de filhos para tipo lógico (logical)
dados3 <- dados3 %>%
  mutate(kid = ifelse(kid0_2 =="Y" | kid3_5 =="Y" | kid6_10 =="Y" | kid11_15 =="Y" | kid16_17 =="Y", 1, 0))

#OBS: mutate(across(starts_with("kid"), as.logical)) Significa converter as colunas que começam com"kid" para dados do tipo lógico.
```

```{r}
#Verificar se está tudo certo com a variavel"kid"
unique(dados3$kid)
```

```{r}
#retirar as colunas:'kid0_2' , 'kid3_5', 'kid6_10' , 'kid11_15' , 'kid16_17'
dados3 <- dados3 %>% select(-kid0_2, -kid3_5,-kid6_10 , -kid11_15, -kid16_17)
```

```{r}
#Verificar se as colunas foram retiradas
ncol(dados3)
```

### Salvar os dados

```{r, message=FALSE, warning=FALSE}
#Alterar o caminho do diretório para a pasta com os datasets
#setwd("C:/0.Projetos/2.Telecom_customer_(Churn)/Dataset")
#dir()
```

```{r}
#Salvar a base de dados
#write.csv(dados3,"dados_transformados.csv", row.names=FALSE)
```

# 6. Análise Descritiva

O objetivo aqui é encontrar variáveis que serão úteis na modelagem. Para isso é necessário identificar padrões e associações, portanto, será feita:

-   A correlação entre as variáveis

-   A criação de gráficos das váriaveis com `churn`

## **6.1 Encontrar associções das variáveis com churn** {.tabset .tabset-pills}

### **Correlação da coluna Churn**

Para realizar uma correlação de Churn com as outras variáveis. É necessário descobrir quais estão em formato numeric. Pois a correlação só é feita com váriaveis númericas.

```{r}
# Verificar quais colunas são numericas
col_numeric <- sapply(dados3, is.numeric)

# Exibir apenas as colunas que são numericas
col_numeric <- dados3[, col_numeric]

# Transformar num data.frame
col_numeric <- data.frame(col_numeric)

```

```{r}
ncol(col_numeric)
```

A tabela tem 76 colunas, é necessário dividi-lá em tabelas menores para visualizar melhor o gráfico de correlação.

```{r, warning=FALSE}
# Dividir o data frame em partes, garantindo a presença da coluna"churn"
partes <- split.default(col_numeric[, -ncol(col_numeric)], 1:7)

# Adicionar a coluna"churn" a cada parte
partes <- lapply(partes, function(parte) {
  cbind(parte, churn = col_numeric$churn)
})

# Salvar cada parte em uma variável separada
for (i in 1:7) {
  assign(paste0("parte", i), partes[[i]])
}
```

Após dividir a base em tabelas menores. Será criado uma uma função para automatizar a construção dos gráficos de correlação.

**Função para criar gráficos de correlação**

```{r}
# Função que automatiza a criação de gráficos de correlação
graf_cor <- function(x){
  ggcorrplot(
    cor(x), 
    hc.order = TRUE,
    type="upper",
    lab=TRUE,
    lab_size = 2.5,
    p.mat=cor_pmat(x), #matriz de p-valores para correlação
    insig="blank"
  )+
    theme(axis.text.x = element_text(angle = 80, hjust = 1))  # Rotacionar rótulos do eixo x
}

#hc.order = TRUE : Ordenamento dasa variveis por agrupamento hierárquico
#type="lower" : esconder espelhamento
#lab=TRUE : adiciona o valor da correlação
#lab_size = 2.5 : ajusta o tamanho da fonte dos rótulos da correlação
#p.mat=cor_pmat() : vai apagar os valores da matriz de correlação que não são significativas.
```

### **Gráfico de correlação 1**

```{r}
graf_pt1 <- graf_cor(parte1)
graf_pt1
```

### **Gráfico de correlação 2**

```{r}
graf_pt2 <- graf_cor(parte2)
graf_pt2
```

### **Gráfico de correlação 3**

```{r}
graf_pt3 <- graf_cor(parte3)
graf_pt3
```

### **Gráfico de correlação 4**

```{r}
graf_pt4 <- graf_cor(parte4)
graf_pt4
```

### **Gráfico de correlação 5**

```{r}
graf_pt5 <- graf_cor(parte5)
graf_pt5
```

### **Gráfico de correlação 6**

```{r}
graf_pt6 <- graf_cor(parte6)
graf_pt6

```

### **Gráfico de correlação 7**

```{r}
graf_pt7 <- graf_cor(parte7)
graf_pt7

```

### **Conclusão**

Foram encontradas 42 correlações altas. A tabela a seguir mostra essas associações:

### Tabela com as variáveis altamente correlacionadas

|     | Variável 1      | Variável 2      | Correlação entre 1 e 2 |
|-----|-----------------|-----------------|------------------------|
| 1   | attempt_Mean    | comp_vce_Mean   | 0.98                   |
| 2   | avgmou          | mou_Mean        | 0.87                   |
| 3   | comp_vce_Mean   | avg6qty         | 0.86                   |
| 4   | attempt_Mean    | avg6qty         | 0.85                   |
| 5   | avg6mou         | mou_cvce_Mean   | 0.83                   |
| 6   | complete_Mean   | mou_Mean        | 0.83                   |
| 7   | avg3mou         | plcd_vc_Mean    | 0.83                   |
| 8   | mou_rvce_Mean   | mou_Mean        | 0.82                   |
| 9   | drop_blck_Mean  | blck_vce_Mean   | 0.82                   |
| 10  | comp_vce_Mean   | mou_peav_Mean   | 0.8                    |
| 11  | peak_vce_Mean   | recv_vce_Mean   | 0.l8                   |
| 12  | attempt_Mean    | mou_peav_Mean   | 0.77                   |
| 13  | complete_Mean   | unan_vce_Mean   | 0.77                   |
| 14  | avg3ty          | inonemin_Mean   | 0.77                   |
| 15  | avgmou          | complete_Mean   | 0.76                   |
| 16  | avgrev          | rev_Mean        | 0.75                   |
| 17  | avg3rev         | ovrrev_Mean     | 0.75                   |
| 18  | avgqty          | opk_vc_Mean     | 0.76                   |
| 19  | owylis_vce_Mean | opk_vc_Mean     | 0.74                   |
| 20  | totmou          | avgqty          | 0.74                   |
| 21  | avgmou          | mou_rvce_Mean   | 0.73                   |
| 22  | complete_Mean   | mou_rvce_Mean   | 0.73                   |
| 23  | avg6ty          | mou_peav_Mean   | 0.71                   |
| 24  | mou_Mean        | avg6rev         | 0.7                    |
| 25  | avgmou          | avg6rev         | 0.68                   |
| 26  | rev_Mean        | mou_peav_Mean   | 0.67                   |
| 27  | avgrev          | mou_peav_Mean   | 0.67                   |
| 28  | owylis_vce_Mean | avgqty          | 0.66                   |
| 29  | avg3mou         | mouowylisv_Mean | 0.65                   |
| 30  | peak_vce_Mean   | adjmou          | 0.65                   |
| 31  | peak_vce_Mean   | avg3rev         | 0.64                   |
| 32  | plcd_vce_Mean   | callwait_Mean   | 0.64                   |
| 33  | mou_Mean        | unan_vce_Mean   | 0.64                   |
| 34  | plcd_vce_Mean   | mouowylisv_Mean | 0.63                   |
| 35  | avgmou          | totcalls        | 0.63                   |
| 36  | mou_pead_Mean   | comp_dat_Mean   | 0.62                   |
| 37  | avgmou          | callwait_Mean   | 0.62                   |
| 38  | av3qty          | drop_vce_Mean   | 0.61                   |
| 39  | avg3qty         | mou_opkv_Mean   | 0.6                    |
| 40  | attempt_Mean    | avgrev          | 0.6                    |
| 41  | comp_vce_Mean   | avgrev          | 0.6                    |
| 42  | mou_rvce_Mean   | avg6rev         | 0.6                    |

Analisando a tabela acima , é possível notar que 7 variáveis aparecem com frequência. São elas:

| Variável      | Descrição                                                  | Quantidade de vezes que aparece |
|---------------|------------------------------------------------------------|---------------------------------|
| avgmou        | Média mensal de minutos de uso ao longo da vida do cliente | 5                               |
| attempt_Mean  | Número médio de tentativas de chamadas                     | 4                               |
| avg3mou       | Média mensal de minutos de uso nos três meses anteriores   | 3                               |
| avg3qty       | Número médio mensal de chamadas nos três meses anteriores  | 3                               |
| comp_vce_Mean | Número médio de chamadas de voz concluídas                 | 3                               |
| complete_Mean | Número médio de chamadas concluídas                        | 3                               |
| peak_vce_Mean | Número médio de chamadas de voz de entrada e saída de pico | 3                               |

A variável `avgmou` também aparece na literaturta como determística de Churn. Isso é um indica ser uma boa ideia deixá-la no dataset final e eliminar as variáveis que são altamente correlacionadas com ela.

## **6.2 Análise Exploratória das variáveis correlacionadas com churn**

### Funções {.tabset .tabset-pills}

Será feita uma analise exploratória das variáveis da tabela acima

#### Função 1 para automatizar a análise de dados númericos

```{r}
#Função que retorna com o summary e com o gráfico de dados numéricos
func_n1 <- function(col) {
  # Calcula o resumo
  resumo <- summary(dados3[[col]])
  describe <-describe(dados3[[col]])
  total <- sum(dados3[[col]], na.rm= TRUE)
  classe <- class(dados3[[col]])

  # Cria o gráfico
  p <- ggplot(dados3, aes_string(x = col, fill = factor(dados3$churn))) +
    geom_histogram(position ="stack", bins = 30, color ="white", alpha = 0.7) +
    labs(
      title = paste('Distribuição de', col, 'Agrupada por Churn'),
      subtitle = paste("Total:", total),
      x = col,
      y = 'Count',
      fill = 'Churn'
    ) +
    theme_minimal() +
    theme(plot.title = element_text(hjust = 0.5)) +
    scale_fill_manual(values = c("blue","red"), name ="Churn", labels = c("0","1")) +
    guides(fill = guide_legend(title ="Churn"))

  print(classe)
  print(resumo)
  print(describe)
  print(p)
  
}
```

#### Função 2 para automatizar a análise de dados númericos

```{r}
#Função que retorna com o summary e com o gráfico de dados numéricos
func_n2 <- function(col){
  # Calcula o resumo
  resumo <- summary(dados3[[col]])
  describe <-describe(dados3[[col]])
  total <- sum(dados3[[col]], na.rm= TRUE)
  classe <- paste("A variável" , col,"é do tipo", class(dados3[[col]]))

  # Cria o gráfico
  p <- ggplot(dados3, aes_string(x = col, fill = factor(dados3$churn))) +
    geom_histogram(position ="dodge", bins = 30, color ="white", alpha = 0.7) +
    labs(
      title = paste('Distribuição de', col, 'Agrupada por Churn'),
      subtitle = paste("Total:", total),
      x = col,
      y = 'Count',
      fill = 'Churn'
    ) +
    theme_minimal() +
    theme(plot.title = element_text(hjust = 0.5)) +
    scale_fill_manual(values = c("blue","red"), name ="Churn", labels = c("0","1")) +
    guides(fill = guide_legend(title ="Churn"))

  cat(classe)
  print(resumo)
  print(describe)
  print(p)
  
}

#OBS: a Função paste serve para concatenar os elementos da mensagem, e cat para imprimir o resultado
```

#### Função 1 para automatizar a análise de dados categóricos

```{r}

func_c1 <- function(col) {
  # Verifica se a coluna é do tipo character
  if (!is.character(dados3[[col]])) {
    stop("A coluna não é do tipo character.")
  }
  
  # Calcula o resumo
  resumo <- table(dados3[[col]])
  
  # Cria o gráfico de barras para variáveis categóricas
  p <- ggplot(dados3, aes_string(x = col, fill = factor(dados3$churn))) +
    geom_bar(position ="stack", color ="white", alpha = 0.7) +
    labs(
      title = paste('Distribuição de', col, 'Agrupada por Churn'),
      x = col,
      y = 'Count',
      fill = 'Churn'
    ) +
    theme_minimal() +
    theme(plot.title = element_text(hjust = 0.5)) +
    scale_fill_manual(values = c("blue","red"), name ="Churn", labels = c("0","1")) +
    guides(fill = guide_legend(title ="Churn"))
  
  print(resumo)
  print(p)
}


```

#### Função 2 para automatizar a análise de dados categóricos

```{r}
func_c2 <- function(col) {
  # Verifica se a coluna é do tipo character
  if (!is.character(dados3[[col]])) {
    stop("A coluna não é do tipo character.")
  }
  
  # Calcula o resumo
  resumo <- table(dados3[[col]])
  
  # Cria o gráfico de barras para variáveis categóricas
  p <- ggplot(dados3, aes_string(x = col, fill = factor(dados3$churn))) +
    geom_bar(position ="dodge", color ="white", alpha = 0.7) +
    labs(
      title = paste('Distribuição de', col, 'Agrupada por Churn'),
      x = col,
      y = 'Count',
      fill = 'Churn'
    ) +
    theme_minimal() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))+
    scale_fill_manual(values = c("blue","red"), name ="Churn", labels = c("0","1")) +
    guides(fill = guide_legend(title ="Churn"))
  
  print(resumo)
  print(p)
}

```

#### Testar numa amostra se o gráfico acima está certo

```{r}
#Função que retorna com o summary e com o gráfico
func_amostra <- function(col) {
  # Calcula o resumo
  resumo <- summary(amostra[[col]])
  describe <-describe(amostra[[col]])
  total <- sum(amostra[[col]], na.rm= TRUE)

  # Cria o gráfico
  p <- ggplot(amostra, aes_string(x = col, fill = factor(amostra$churn))) +
    geom_histogram(position ="stack", bins = 30, color ="white", alpha = 0.7) +
    labs(
      title = paste('Distribuição de', col, 'Agrupada por Churn'),
      subtitle = paste("Total:", total),
      x = col,
      y = 'Count',
      fill = 'Churn'
    ) +
    theme_minimal() +
    theme(plot.title = element_text(hjust = 0.5)) +
    scale_fill_manual(values = c("blue","red"), name ="Churn", labels = c("0","1")) +
    guides(fill = guide_legend(title ="Churn"))

  print(resumo)
  print(describe)
  print(p)
  
}
```

```{r}
#Criar uma amostra para conferir se o gráfico foi feito corretamente
amostra<- dados3[sample(nrow(dados3), 50),]
```

```{r}
amostra <- amostra %>% select(drop_vce_Mean, churn)
```

```{r}
#amostra
```

```{r}
func_amostra("drop_vce_Mean")
```

### Teste de Hipótese

Para realizar o gráfico será criada duas tabelas , uma com amostra dos dados quando churn for igual a 0 e outra tabela quando churn for igual a 1. E em seguida, será feito o teste comparando a distribuição dessas duas tabelas.

#### Amostragem aleatória

```{r}
#Definir a semente

set.seed(123)  # Define uma semente para reproducibilidade

# Criar um dataframe com os dados quando churn =0

df_churn_0 <- dados3[dados3$churn == 0, ]

## Criar um dataframe com os dados quando churn =0

df_churn_1 <- dados3[dados3$churn == 1, ]

# Tamanho da amostra para churn=0 (mesmo tamanho que churn=1)

tamanho_amostra <- min(nrow(df_churn_0), nrow(df_churn_1))

#OBS: tamanho_amostra é o tamanho da amostra desejado, que é o menor entre o tamanho de amostra_churn_0 e amostra_churn_1.

# Amostragem aleatória

amostra_churn_0 <- df_churn_0[sample(nrow(df_churn_0), tamanho_amostra, replace = TRUE), ]

amostra_churn_1 <- df_churn_1[sample(nrow(df_churn_1), tamanho_amostra, replace = TRUE), ]

#OBS:replace = TRUE

# - Amostragem com substituição.

# - Isso significa que a mesma observação pode ser escolhida mais de uma vez durante o processo de amostragem. Cada vez que uma observação é escolhida, ela é devolvida à população antes da próxima escolha.


```

#### Teste de Hipótese - Kolmogorov-Smirnov

É um teste não paramétrico que compara as funções de distribuição de duas amostras

$H_0: As \ distribuições \ são \ iguais$

$H_1: As\ distribuições \ são \ diferentes$

O nível de significância será de 0.05 e critério de avaliação será pelo p-valor. Se o p-valor for maior que 0.05, rejeita-se $H_0$, logo as amostras tem a mesma distribuição. Isso será um indicativo de que a variável testada não é uma boa preditora.

Agora, se o p-valor for menor que 0.05, então rejeita-se $H_0$, logo as amostras tem distribuições diferentes, portanto, a variável análisada é uma boa preditora de churn.

O objetivo do teste é ajudar a encontrar boas preditoras de churn.

```{r}
teste_ks <- function(x){
  t <- ks.test(amostra_churn_0[[x]], amostra_churn_1[[x]])
  print(t)
}

```

### \*\*\*6.2.1 months

```{r}
class(dados3$months)
```

```{r}
func_n2("months")
```

```{r}
teste_ks("months")
```

### 6.2.2 truck

```{r}
class(dados3$truck)
```

```{r}
unique(dados3$truck)
```

```{r, message=FALSE, warning=FALSE}
func_n2("truck")
```

A análise gráfica mostra que não uma grande diferença entre as distribuições. Logo, esta não é uma boa preditora.

### 6.2.3 rv

```{r}
func_n2("rv")
```

### \*\*\*6.2.4 drop_vce_Mean

```{r}
class(dados3$drop_vce_Mean)
```

```{r}
func_n2("drop_vce_Mean")
```

```{r}
teste_ks("drop_vce_Mean")
```

### \*6.2.5 drop_dat_Mean

```{r}
func_n2("drop_dat_Mean")
```

### \*6.2.5 blck_vce_Mean

```{r}
func_n2("blck_vce_Mean")
```

```{r}
teste_ks("blck_vce_Mean")
```

### \*6.2.6 blck_dat_Mean

```{r}
unique(dados3$blck_dat_Mean)
```

```{r}
func_n2("blck_dat_Mean")
```

```{r}
teste_ks("blck_vce_Mean")
```

### \*\*\*6.2.7 hnd_price

```{r}
func_n2("hnd_price")
```

```{r}
teste_ks("hnd_price")
```

### \*6.2.8 avgqty

```{r}
func_n2("avgqty")
```

```{r}
teste_ks("avgqty")
```

### \*\*\*6.2.9 rev_Mean

```{r}
func_n2("rev_Mean")
```

```{r}
teste_ks("rev_Mean")
```

### \*\*\*6.2.10 totmrc_Mean

```{r}
func_n2("totmrc_Mean")
```

```{r}
teste_ks("totmrc_Mean")
```

### \*\*\*6.2.11 eqpdays

Segundo (LEE et al., 2011) , a variável número de dias do equipamento atual (eqpdays) "está positivamente associada à decisão de desligamento dos usuários do serviço, o que significa que um usuário do serviço que manteve seu atual equipamento móvel por mais tempo terá maior probabilidade de mudar para outro provedor de serviços". Logo, quanto maior o eqpdays, maior a chances de churn.

```{r}
func_n2("eqpdays")
```

```{r}
teste_ks("eqpdays")
```

### \*6.2.12 ovrmou_Mean

```{r}
func_n2("ovrmou_Mean")
```

```{r}
teste_ks("ovrmou_Mean")
```

### \*\*6.2.13 mou_cvce_Mean

```{r}
class(dados3$mou_cvce_Mean)
```

```{r}
func_n2("mou_cvce_Mean")
```

```{r}
teste_ks("mou_cvce_Mean")
```

### \*\*\*6.2.14 asl_flag

```{r}
class(dados3$asl_flag)
```

```{r}
func_c2("asl_flag")
```

### \*\*\*6.2.15 totmou

```{r}
class(dados3$totmou)
```

```{r}
func_n2("totmou")
```

```{r}
teste_ks("totmou")
```

### \*6.2.16 avgmou

```{r}
class(dados3$avgmou)
```

```{r}
func_n2("avgmou")
```

```{r}
teste_ks("avgmou")

```

### \*6.2.17 vceovr_Mean

```{r}
class(dados3$vceovr_Mean)
```

```{r}
func_n2("vceovr_Mean")
```

```{r}
teste_ks("vceovr_Mean")
```

### \*6.2.18 ovrrev_Mean

```{r}
class(dados3$ovrrev_Mean)
```

```{r}
func_n2("ovrrev_Mean")
```

```{r}
teste_ks("ovrrev_Mean")
```

### \*\*\*6.2.19 change_mou

```{r}
class(dados3$change_mou)
```

```{r}
func_n2("change_mou")
```

```{r}
teste_ks("change_mou")
```

### \*6.2.20 refurb_new

```{r}
class(dados3$refurb_new)
```

```{r}
func_c2("refurb_new")
```

```{r}
teste_ks("ovrrev_Mean")
```

### \*\*\*6.2.21 hnd_webcap

```{r}
class(dados3$hnd_webcap)
```

```{r}
unique(dados3$hnd_webcap)
```

```{r}
func_c2("hnd_webcap")
```

### \*\*\*6.2.22 area

```{r}
class(dados3$area)
```

```{r}
unique(dados3$area)
```

```{r}
func_c2("area")
```

### \*6.2.23 income:

```{r}
func_n2("income")
```

```{r}
teste_ks("income")
```

### \*6.2.24 roam_Mean

```{r}
class(dados3$roam_Mean)
```

```{r}
func_n2("roam_Mean")
```

```{r}
teste_ks("roam_Mean")
```

### \*6.2.25 cc_mou_Mean

```{r}
func_n2("cc_mou_Mean")
```

------------------------------------------------------------------------

### \#

### \*6.2.26 attempt_Mean

```{r}
func_n2("attempt_Mean")
```

```{r}
teste_ks("attempt_Mean")
```

O p-valor é maior que o nível de significância. Logo, não há evidências para rejeitar H0.

### \*6.2.27 avg3mou

```{r}
func_n2("avg3mou")
```

```{r}
teste_ks("avg3mou")
```

O teste deu um p-valor muito alto, portanto, não há indicios para rejeitar H0. Logo, esta variável não é uma boa preditora.

### \*\*6.2.28 avg3rev

```{r}
func_n2("avg3rev")
```

```{r}
teste_ks("avg3rev")
```

O teste deu um p-valor menor que o nível de significância. Logo, há um indícios que as amostras tem distribuições diferentes. Portanto, esta é uma boa variável preditora

### 6.2.28 avg6mou

```{r}
func_n2("avg6mou")
```

```{r}
teste_ks("avg6mou")
```

O p-valor deu um resultado próximo porém acima do nível de significância. Logo, há indícios que as amostras tem a mesma distribuição, porém o resultado não é conclusivo.

### 6.2.29 avg3qty

```{r}
func_n2("avg3qty")
```

```{r}
teste_ks("avg3qty")
```

O p-valor é maior que o nível de significância.Log, esta não é uma boa variável preditora.

### 6.2.30 avg6qty

```{r}
func_n2("avg6qty")

```

```{r}
teste_ks("avg6qty")
```

O p-valor é maior que o nível de significância.Log, esta não é uma boa variável preditora.

### \*6.2.31 avgrev

```{r}

func_n2("avgrev")
```

```{r}
teste_ks("avgrev")
```

O p-valor é maior que o nível de significância.Log, esta não é uma boa variável preditora.

### \*6.2.32 comp_vce_Mean

```{r}
func_n2("comp_vce_Mean")
```

```{r}
teste_ks("comp_vce_Mean")
```

O p-valor é maior que o nível de significância.Log, esta não é uma boa variável preditora.

### \*\*\*6.2.33 complete_Mean

```{r}
func_n2("complete_Mean")
```

```{r}
teste_ks("complete_Mean")
```

O p-valor é menor que o nível de significância, sendo este um indício para rejeitar H0. Portanto, há evidências de que as amostras tem distribuições diferentes. Conclui-se que esta é uma boa variável preditora.

### \*\*6.2.34 drop_blk_Mean

```{r}
class(dados2$drop_blck_Mean)
```

```{r}
func_n2("drop_blk_Mean")
```

```{r}
teste_ks("drop_blk_Mean")
```

O p-valor é muito alto, logo, há indícios que está não é uma boa preditora.

### \*\*6.2.35 mou_Mean

```{r}
func_n2("mou_Mean")
```

```{r}
teste_ks("mou_Mean")
```

### \*6.2.36 mou_pead_Mean

```{r}
head(dados3$mou_pead_Mean)
```

```{r}
func_n2("mou_pead_Mean")
```

```{r}
teste_ks("mou_pead_Mean")
```

O p-valor é muito alto, logo, esta não é uma boa variável preditora.

### \*6.2.37 mou_rvce_Mean

```{r}
func_n2("mou_rvce_Mean")
```

```{r}
teste_ks("mou_rvce_Mean")
```

O p-valor é muito alto, logo, esta não é uma boa variável preditora.

### \*6.2.38 owylis_vce_Mean

```{r}
func_n2("owylis_vce_Mean")
```

```{r}
teste_ks("owylis_vce_Mean")
```

O p-valor é muito alto, logo, esta não é uma boa variável preditora.

### \*\*6.2.39 peak_vce_Mean

```{r}
func_n2("peak_vce_Mean")
```

```{r}
teste_ks("peak_vce_Mean")
```

O p-valor é menor que o nível de significância (0.05), isto é um indício para rejeitar H0. Logo, é provável que as amostras tenham distribuições diferentes. Conclui-se que esta é uma boa variável preditora.

### \*\*6.2.40 plcd_vce_Mean

```{r}
func_n2("plcd_vce_Mean")
```

Pela análise gráfica, nota-se uma diferença entre as duas distribuições. Logo, há indícios que esta seja uma variável preditora.

### 6.2.41 mou_Mean

```{r}
func_n2("mou_Mean")
```

```{r}
teste_ks("mou_Mean")
```

O p-valor é maior que o nível de significância. Logo, esta variável não é uma boa preditora

### 6.2.42 da_Mean

```{r}
func_n2("da_Mean")
```

```{r}
teste_ks("da_Mean")
```

O p-valor deu um número muito alto. Esta não é uma boa preditora.

### 6.2.41 datovr_Mean

```{r}
func_n2("datovr_Mean")

```

```{r}
teste_ks("datovr_Mean")
```

O p-valor deu um número muito alto. Esta não é uma boa preditora.

### 6.2.43 change_rev

```{r}
func_n2("change_rev")
```

```{r}
teste_ks("change_rev")
```

O p-valor deu um número muito alto. Esta não é uma boa preditora.

### \*\*6.2.44 unan_vce_Mean

```{r}
func_n2("unan_vce_Mean")
```

```{r}
teste_ks("unan_vce_Mean")
```

O p-valor deu um resultado menor que o nível de significância (0.05), portanto rejeita-se H0, isso significa que há indícios que as duas amostras tenham distribuições diferentes.

Com o resultado do teste de hipótese junto com a análise do gráfico, é possível concluir que esta é uma boa variável preditora.

### 6.2.45 unan_dat_Mean

```{r}
func_n2("unan_dat_Mean")
```

```{r}
teste_ks("unan_dat_Mean")
```

O p-valor é muito alto , portanto, esta não é uma boa variável preditora.

### \*\*\*6.2.46 plcd_vce_Mean

```{r}
func_n2("plcd_vce_Mean")

```

Ao analisar o gráfico é possível perceber grandes diferenças entre as duas distribuições. Logo, esta é uma boa variável preditora.

### 6.2.47 plcd_dat_Mean

```{r}
func_n2("plcd_dat_Mean")
```

```{r}
teste_ks("plcd_dat_Mean")
```

### 6.2.48 recv_vce_Mean

```{r}
func_n2("recv_vce_Mean")
```

```{r}
teste_ks("recv_vce_Mean")
```

O p-valor deu um resultado muito alto. Portanto, esta não é uma boa variável preditora.

### 6.2.49 recv_vce_Mean

```{r}
func_n2("recv_vce_Mean")
```

```{r}
teste_ks("recv_vce_Mean")
```

O p-valor deu um resultado muito alto. Portanto, esta não é uma boa variável preditora.

### 6.2.50 recv_sms_Mean

```{r}
func_n2("recv_sms_Mean")
```

```{r}
teste_ks("recv_sms_Mean")
```

O p-valor deu um resultado muito alto. Portanto, esta não é uma boa variável preditora.

### 6.2.51 comp_dat_Mean

```{r}
func_n2("comp_dat_Mean")
```

Esta não é uma boa variável preditora

### 6.2.52 custcare_Mean

```{r}
func_n2("custcare_Mean")
```

```{r}
teste_ks("custcare_Mean")
```

O p-valor deu um resultado muito alto. Portanto, esta não é uma boa variável preditora.

### 6.2.53 inonemin_Mean

```{r}
func_n2("inonemin_Mean")
```

```{r}
teste_ks("inonemin_Mean")
```

O p-valor deu um resultado muito alto. Portanto, esta não é uma boa variável preditora.

### 6.2.54 threeway_Mean

```{r}
func_n2("threeway_Mean")
```

```{r}
teste_ks("threeway_Mean")
```

O p-valor deu um resultado muito alto. Portanto, esta não é uma boa variável preditora.

### 6.2.55 mou_cdat_Mean

```{r}
func_n2("mou_cdat_Mean")
teste_ks("mou_cdat_Mean")
```

O p-valor deu um resultado muito alto. Portanto, esta não é uma boa variável preditora.

### 6.2.56 mou_rvce_Mean

```{r}
func_n2("mou_rvce_Mean")
teste_ks("mou_rvce_Mean")
```

O p-valor deu um resultado muito alto. Portanto, esta não é uma boa variável preditora.

### 6.2.57 owylis_vce_Mean

```{r}
func_n2("owylis_vce_Mean")
teste_ks("owylis_vce_Mean")
```

O p-valor deu um resultado muito alto. Portanto, esta não é uma boa variável preditora.

### 6.2.57 mouowylisv_Mean

```{r}
func_n2("mouowylisv_Mean")
teste_ks("mouowylisv_Mean")
```

O p-valor deu um resultado muito alto. Portanto, esta não é uma boa variável preditora.

### 6.2.58 peak_dat_Mean

```{r}
func_n2("peak_dat_Mean")
teste_ks("peak_dat_Mean")
```

O p-valor deu um resultado muito alto. Portanto, esta não é uma boa variável preditora.

### 6.2.59 mou_peav_Mean

```{r}
func_n2("mou_peav_Mean")
```

```{r}
teste_ks("mou_peav_Mean")
```

O p-valor deu um resultado muito alto. Portanto, esta não é uma boa variável preditora.

### 6.2.60 mou_pead_Mean

```{r}
func_n2("mou_pead_Mean")
teste_ks("mou_pead_Mean")
```

O p-valor deu um resultado muito alto. Portanto, esta não é uma boa variável preditora.

### 6.2.61 opk_vce_Mean

```{r}
func_n2("opk_vce_Mean")
teste_ks("opk_vce_Mean")
```

O p-valor deu um resultado muito alto. Portanto, esta não é uma boa variável preditora.

### 6.2.62 mou_opkv_Mean

```{r}
func_n2("mou_opkv_Mean")
teste_ks("mou_opkv_Mean")
```

O p-valor deu um resultado muito alto. Portanto, esta não é uma boa variável preditora.

### 6.2.63 drop_blk_Mean

```{r}
func_n2("drop_blk_Mean")
teste_ks("drop_blk_Mean")
```

O p-valor deu um resultado muito alto. Portanto, esta não é uma boa variável preditora.

### 6.2.64 callfwdv_Mean

```{r}
func_n2("callfwdv_Mean")
```

```{r}
teste_ks("callfwdv_Mean")
```

O p-valor deu um resultado muito alto. Portanto, esta não é uma boa variável preditora.

### 6.2.65 uniqsubs

```{r}
func_n2("uniqsubs")
teste_ks("uniqsubs")
```

O p-valor deu um resultado muito alto. Portanto, esta não é uma boa variável preditora.

### 6.2.67 actvsubs

```{r}
func_n2("actvsubs")
teste_ks("actvsubs")
```

O p-valor deu um resultado muito alto. Portanto, esta não é uma boa variável preditora.

### 6.2.68 new_cell

```{r}
func_c2("new_cell")
```

As variáveis são do tipo categóricas e há uma leve variação nas distribuições.Pela análise gráfica conclui-se que há indícios dessa variável ser uma boa preditora.

### 6.2.69 crclscod

```{r}
func_c2("crclscod")
```

Observa-se uma leve variação nas duas distribuições. E, esta variável ajuda a entender o perfil de cada cliente. Portanto, é uma boa variável preditora.

### \*\*\*6.2.70 totcalls

```{r}
func_n2("totcalls")
teste_ks("totcalls")
```

O p-valor deu um resultado menor que o nível de significância.Isso junto com a análise gráfica, leva a crer que esta é uma boa variável preditora.

### \*\*6.2.71 totrev

```{r}
func_n2("totrev")
teste_ks("totrev")
```

O p-valor deu um resultado menor que o nível de significância.Isso junto com a análise gráfica, leva a crer que esta é uma boa variável preditora.

### \*\*\*6.2.72 adjrev

```{r}
func_n2("adjrev")
teste_ks("adjrev")
```

O p-valor deu um resultado menor que o nível de significância.Isso junto com a análise gráfica, leva a crer que esta é uma boa variável preditora.

### \*\*6.2.73 adjmou

```{r}
func_n2("adjmou")
teste_ks("adjmou")
```

O p-valor deu um resultado menor que o nível de significância.Isso junto com a análise gráfica, leva a crer que esta é uma boa variável preditora.

### \*\*6.2.75 adjqty

```{r}
func_n2("adjqty")
teste_ks("adjqty")
```

O p-valor deu um resultado menor que o nível de significância.Isso junto com a análise gráfica, leva a crer que esta é uma boa variável preditora.

### 6.2.76 avgrev

```{r}
func_n2("avgrev")
teste_ks("avgrev")
```

O p-valor deu um resultado muito alto. Portanto, esta não é uma boa variável preditora.

### 6.2.77 avg6mou

```{r}
func_n2("avg6mou")
teste_ks("avg6mou")
```

O p-valor deu um resultado um pouco acima do nível de significância. Isso é um indício que esta variável não é uma boa preditora, porém não é algo conclusivo.

### 6.2.78 avg6qty

```{r}
func_n2("avg6qty")
teste_ks("avg6qty")
```

O p-valor deu um resultado um pouco acima do nível de significância. Isso éum indício que esta variável não é uma boa preditora, porém não é algo conclusivo.

### \*\*6.2.79 avg6rev

```{r}
func_n2("avg6rev")
teste_ks("avg6rev")
```

O p-valor (0.05486) deu um resultado um pouco acima do nível de significância (0.05).Porém, como a diferença foi menos de 1% e a análise gráfica mostra que há diferenças sutis nas duas distribuições. Esta variável será considerada uma boa preditora.

### 6.2.80 phones

```{r}
func_n2("phones")
teste_ks("phones")
```

O p-valor deu um resultado muito alto. Portanto, esta não é uma boa variável preditora.

### 6.2.81 models

```{r}
func_n2("models")
teste_ks("models")
```

O p-valor deu um resultado muito alto. Portanto, esta não é uma boa variável preditora.

### \*\*\*6.2.82 ownrent

```{r}
func_c2("ownrent")

```

Pela análise gráfica é possível notar que diferença nas duas distribuições. Logo esta é uma boa variável preditora.

### \*\*\*6.2.83 dwlltype

```{r}
func_c2("dwlltype")
```

Pela análise gráfica é possível notar que diferença nas duas distribuições. Logo esta é uma boa variável preditora.

### \*\*\*6.2.84 marital

```{r}
func_c2("marital")
```

Pela análise gráfica é possível notar que diferença nas duas distribuições. Logo esta é uma boa variável preditora.

### 6.2.85 numbcars

```{r}
func_n2("numbcars")
teste_ks("numbcars")
```

### 6.2.86 HHstatin

```{r}
func_c2("HHstatin")
```

### 6.2.87 dwllsize

```{r}
func_c2("dwllsize")

```

### 6.2.88 ethnic

```{r}
func_c2("ethnic")
```

### 6.2.89 kid

```{r}
func_n2("kid")
teste_ks("kid")
```

### 6.2.90 creditcd

```{r}
func_c2("creditcd")

```

A análise gráfica leva a crer que esta é uma boa variável preditora.

## 6.3 Pré-seleção das variáveis preditoras

Foram pré-selecionadas 41 variáveis preditoras.Agora será análisado a correlação de entre elas.

![](images/Pre%20selecao-%20p-valor%20e%20correlação.png)

O critério para seleção da variável será com base no p-valor. As variáveis que tiverem o p-valor maior da dupla, serão eliminadas.

Portanto, as variáveis eliminadas da seleção são:

-   avg3rev

-   adjmou

## 6.4 Variáveis selecionadas

### 6.4.1 Seleção inicial

Será criado um data frame com as 39 variáveis selecionadas para modelagem.Além da coluna churn.

![](images/Variaveis%20selecionadas.png){width="595"}

```{r}
df_final <- dados3 %>% select(
  "churn",
  "months",
 "drop_vce_Mean",
 "drop_dat_Mean", 
 "blck_vce_Mean",
 "blck_dat_Mean",
 "hnd_price",
 "avgqty",
 "rev_Mean",
 "totmrc_Mean",
 "eqpdays",
 "ovrmou_Mean",
 "mou_cvce_Mean",
 "asl_flag",
 "totmou",
 "avgmou",
 "vceovr_Mean",
 "ovrrev_Mean",
 "change_mou",
 "refurb_new",
 "hnd_webcap",
 "area",
 "income", 
 "roam_Mean",
 "cc_mou_Mean",
 "complete_Mean",
 "peak_vce_Mean",
 "unan_vce_Mean",
 "plcd_vce_Mean",
 "new_cell",
 "crclscod",
 "totcalls",
 "totrev",
 "adjmou",
 "adjqty",
 "avg6rev",
 "ownrent",
 "dwlltype",
 "marital",
 "creditcd"
)
```

```{r}
#Verificar se todas as colunas foram incluídas
ncol(df_final)

#Salvar a tabela
#write.csv(df_final,"df_final.csv", row.names = FALSE)
```

```{r}
df_final <- read.csv("df_final.csv")
```

### 6.4.2 Transformar colunas categóricas em numéricas

Antes de comerçar a modelagem é necessário transformar as colunas categóricas em númericas

```{r}
# Identificar colunas não numéricas
colunas_nao_numericas <- names(df_final)[!sapply(df_final, is.numeric)]

# Imprimir as colunas não numéricas
print(colunas_nao_numericas)
```

#### asl_flag

```{r}
unique(df_final$asl_flag)
```

```{r}
df_final1 <- df_final %>% 
  dummy_cols(select_columns = c("asl_flag")) %>% 
  subset(select = -asl_flag)
 
```

#### refurb_new

```{r}
unique(df_final$refurb_new)
```

```{r}
df_final1 <- df_final1 %>% 
  dummy_cols(select_columns = c("refurb_new")) %>% 
  subset(select=-refurb_new)
```

#### hnd_webcap

```{r}
unique(df_final$hnd_webcap)
```

```{r}
df_final1 <- df_final1 %>% 
  dummy_cols(select_columns = c("hnd_webcap")) %>% 
  subset(select=-hnd_webcap)
```

#### area

```{r}
unique(df_final1$area)
```

```{r}
df_final1 <- df_final1 %>% mutate(
  area = case_when(
    area =="NORTHWEST/ROCKY MOUNTAIN AREA" ~ "oeste",
    area =="NEW ENGLAND AREA" ~ "nordeste",
    area =="GREAT LAKES AREA" ~ "centro_oeste", 
    area =="DALLAS AREA" ~ "sudoeste",
    area =="CENTRAL/SOUTH TEXAS AREA" ~ "sudoeste",
    area =="CHICAGO AREA" ~ "centro_oeste",
    area =="TENNESSEE AREA" ~ "sudeste",
    area =="MIDWEST AREA" ~ "centro_oeste" ,
    area =="PHILADELPHIA AREA" ~ "nordeste",
    area =="SOUTHWEST AREA" ~ "sudoeste",
    area =="OHIO AREA" ~ "centro_oeste",
    area =="NEW YORK CITY AREA" ~ "nordeste",
    area =="HOUSTON AREA" ~ "sudoeste" , 
    area =="SOUTH FLORIDA AREA" ~ "sudeste", 
    area =="ATLANTIC SOUTH AREA" ~ "sudeste",
    area =="CALIFORNIA NORTH AREA" ~ "oeste",
    area =="DC/MARYLAND/VIRGINIA AREA" ~ "nordeste",
    area =="NORTH FLORIDA AREA" ~ "sudeste", 
    area =="LOS ANGELES AREA" ~ "oeste",
    TRUE ~ as.character(area)
  )
)

```

```{r}
df_final1 <- df_final1 %>% 
  dummy_cols(select_columns = c("area")) %>% 
  subset(select=-area)
```

```{r}
# Calcular a porcentagem de 1s em relação ao total
porcentagem_1 <- 100 * (mean(df_final1$area_ ))

# Exibir o resultado
print(porcentagem_1)
```

```{r}
df_final1 <- df_final1 %>% subset(select=-area_)
```

#### new_cell

```{r}
unique(df_final$new_cell)
```

```{r}
df_final1 <- df_final1 %>% 
  dummy_cols(select_columns = c("new_cell")) %>% 
  subset(select=-new_cell)
```

#### (?) crclscod

```{r}
unique(df_final$crclscod)
```

```{r}
df_final1<- df_final1 %>% 
  subset(select=-crclscod)

```

#### ownrent

```{r}
unique(df_final$ownrent)
```

```{r}
df_final1 <- df_final1 %>% 
  dummy_cols(select_columns = c("ownrent")) %>% 
  subset(select=-ownrent)
```

```{r}
# Calcular a porcentagem de 1s em relação ao total
porcentagem_1 <- 100 * (mean(df_final1$ownrent_ ))

# Exibir o resultado
print(porcentagem_1)
```

```{r}
df_final1 <- df_final1 %>%  subset(select=- ownrent_)
```

#### dwlltype

```{r}
unique(df_final$dwlltype)
```

```{r}
df_final1 <- df_final1 %>% 
  dummy_cols(select_columns = c("dwlltype")) %>% 
  subset(select=-dwlltype)
```

```{r}
# Calcular a porcentagem de 1s em relação ao total
porcentagem_1 <- 100 * (mean(df_final1$dwlltype_ ))

# Exibir o resultado
print(porcentagem_1)
```

```{r}
df_final1 <- df_final1 %>% subset(select=-dwlltype_)
```

### marital

```{r}
unique(df_final$marital)
```

```{r}
df_final1 <- df_final1 %>% 
  dummy_cols(select_columns = c("marital")) %>% 
  subset(select=-marital)
```

### creditcd

```{r}
unique(df_final$creditcd)
```

```{r}
df_final1 <- df_final1 %>% 
  dummy_cols(select_columns = c("creditcd")) %>% 
  subset(select=-creditcd)
```

### 6.4.2 Salvar a tabela que será usada na modelagem

```{r}
#Verificar quantidade de colunas 
ncol(df_final1)

#Salvar a tabela
#write.csv(df_final1,"df_final_modelagem.csv", row.names = FALSE)
```

```{r}
df_final1 <- read.csv("df_final_modelagem.csv")
```


# Referências

GOPAL, R. K.; MEHER, S. K. Customer Churn Time Prediction in Mobile Telecommunication Industry Using Ordinal Regression. p. 884--889, 20 maio 2008. Disponível em: <https://link.springer.com/chapter/10.1007/978-3-540-68125-0_88>

HUNG, S.-Y.; YEN, D. C.; WANG, H.-Y. Applying data mining to telecom churn management. Expert Systems with Applications, v. 31, n. 3, p. 515--524, out. 2006.Disponível em : <https://www.sciencedirect.com/science/article/pii/S0957417405002654>

KIM, H.-S.; YOON, C.-H. Determinants of subscriber churn and customer loyalty in the Korean mobile telephony market. Telecommunications Policy, v. 28, n. 9-10, p. 751--765, out. 2004. Disponível em: <https://www.sciencedirect.com/science/article/pii/S0308596104000783>

LEE, H. et al. Mining churning behaviors and developing retention strategies based on a partial least squares (PLS) model. Decision Support Systems, v. 52, n. 1, p. 207--216, dez. 2011.Disponível em: <https://www.sciencedirect.com/science/article/pii/S0167923611001254>

LU, N. et al. A Customer Churn Prediction Model in Telecom Industry Using Boosting. IEEE Transactions on Industrial Informatics, v. 10, n. 2, p. 1659--1665, maio 2014.Disponível em: <https://ieeexplore.ieee.org/abstract/document/6329952>

TSAI, C.-F.; CHEN, M.-Y. Variable selection by association rules for customer churn prediction of multimedia on demand. Expert Systems with Applications, v. 37, n. 3, p. 2006--2015, 15 mar. 2010.Disponível em: <https://www.sciencedirect.com/science/article/pii/S0957417409006459>

KERAMATI, A. et al. Improved churn prediction in telecommunication industry using data mining techniques. **Applied Soft Computing**, v. 24, p. 994--1012, nov. 2014. Disponível em: <https://www.sciencedirect.com/science/article/pii/S1568494614004062>

ZHANG, X. et al. Predicting customer churn through interpersonal influence. Knowledge-KERAMATI, A. et al. Improved churn prediction in telecommunication industry using data mining techniques. **Applied Soft Computing**, v. 24, p. 994--1012, nov. 2014.Based Systems, v. 28, p. 97--104, abr. 2012. Disponível em: <https://www.sciencedirect.com/science/article/pii/S0950705111002693>o
